# Processos

Cria um processo com ``fork()``
  - Exemplo em ``fork.c``
  - Retorno:
    - para o filho: 0
    - para o pai: PID do filho
    - erro: -1
  - Duplica o processo atual, executando o novo processo num espaço de memória
  diferente.

Nos SO baseado em UNIX, o processo raiz (pai de todos os processos) é o **init**

### Quatro eventos para processos serem criados:

1. Inicialização do sistema.
2. Execução de uma chamada de sistema de criação de processo por um processo
em execução
3. Solicitação de um usuário para criar um novo processo
4. Início de uma tarefa em lote

### Condições que podem provocar o término de um processo

1. Saída normal (voluntária)
  - ``exit()``
2. Saída por erro (voluntária)
  - ex: ``gcc filename.c`` (mas filename.c não existe)
3. Erro Fatal (involuntária)
  - divisão por 0
  - segmetation fault (acesso indevido à memória)
  - execução de uma instrução ilegal
4. Destruído por outro processo (involuntária)
  - sinais (kill)

### Estados de um processo:

1. Em execução: realmente usando a CPU naquele instante
2. Pronto: executável, temporariamente parado para deixar outro processo
ser executado
3. Bloqueado: incapaz de ser executado até que algum evento externo aconteça
  - pode acontecer de duas formas:
    - chamada de sistema (block ou pause - SIGSTOP também ??)
    - quando não há entradas disponíveis para que o processo continue sua
    execução
4. Indefinido: processo desconhecido ao nível do SO

Transições entre **em execução** e **pronto** podem ocorrem num escalonamento de processos

### Tipos de Processos

- CPU-bound: procesos que utilizam muito o processador
  - tempo de exucução definido pelos ciclos de processador
- I/O-bound: processos que realizam muito entrada e saída
  - tempo de execução definido pela duração das operações E/S

O ideal é um balanceamento entre CPU-buond e I/O-bound

### Processos zombies:

Ocorre quando o processo filho acaba antes do processo pai sem o tratamento
adequado (wait ou waitpid). O processo está morto, portando não podemos usar
SIGKILL para matá-lo, mas ocupa espaço na memória.

# Sinais

- SO oferece sinais para enviar a algum processo
- Há como realizar tratamento de sinais
  - Obs: SIGKILL e SIGSTOP não podem ser capturados, bloqueados ou ignorados!
- Pode ser enviado sinais diretamento com kill
  - ``kill(pid_t pid, int sig)``

# Threads

Thread é uma linha de execução em um processo. E cada processo tem pelo menos uma thread

- As threads de um processo compartilham:
  - Espaço de endereço
  - Variáveis globais
  - Vetor de arquivos abertos
  - Processos filhos
  - Alarmes pendentes
  - O mesmo PID

- Cada thread tem seus próprios recursos:
  - PC
  - Registradores
  - Pilha
  - Estado
  - TID (identificador da thread)

Esquema para compartilhamaento de recursos do processo entre suas threads:

```
+-----------------------------------------------------------------------+ 
| Process                                                               | 
|   +-------+     +-------------+  +-------------+  +-------------+     | 
|   | Files |     | Thread      |  | Thread      |  | Thread      |     | 
|   +-------+     |+-----------+|  |+-----------+|  |+-----------+|     | 
|                 || Registers ||  || Registers ||  || Registers ||     | 
|                 |+-----------+|  |+-----------+|  |+-----------+|     | 
| ....................................................................  | 
| . Memory        |             |  |             |  |             |  .  | 
| .               | +---------+ |  | +---------+ |  | +---------+ |  .  | 
| . +--------+    | |  Stack  | |  | |  Stack  | |  | |  Stack  | |  .  | 
| . |  Heap  |    | |         | |  | |         | |  | |         | |  .  | 
| . +--------+    | |         | |  | |         | |  | |         | |  .  | 
| .               | |         | |  | |         | |  | |         | |  .  | 
| . +--------+    | |         | |  | |         | |  | |         | |  .  | 
| . | Static |    | |         | |  | |         | |  | |         | |  .  | 
| . +--------+    | |         | |  | |         | |  | |         | |  .  | 
| .               | |         | |  | |         | |  | |         | |  .  | 
| . +--------+    | |         | |  | |         | |  | |         | |  .  | 
| . |  Code  |    | +---------+ |  | +---------+ |  | +---------+ |  .  | 
| . +--------+    +-------------+  +-------------+  +-------------+  .  | 
| ....................................................................  | 
+-----------------------------------------------------------------------+ 

```

No Linux, as as threads e processos são tratados como tarefas, ou seja, não 
são vistas da mesma forma pelo SO. Só muda o que é compartilhado na memória
  - Isso é diferenciado pela chamada ``clone`` passando parametros diferentes

### Tipos de threads

- Modo usuário
  - As threads são implementadas por bibliotecas no nível do usuário
  - Criação e escalanomento são feitos sem usar o kernel (e são desconhecidas pelo kernel)
  - Cada processo tem sua própria tabela de threads
  - **Vantagens:**
    - Alternância de threads são mais rápidas
    - Tem menos chamadas ao kernel
    - Permite que cada processo tenha seu próprio algoritmo de escalonamento
  - **Desvantagem:**
    - Processo inteiro é bloqueado se uma thread realizar uma chamada bloqueante ao sistema
- Modo kernel:
  - Suportadas diretamente pelo SO
  - Escalonamento e gerenciamento feito pelo kernel
    - Tabela de threads e tabelas de processos separadas
  - **Vantagem:**
    - Processo inteiro não é bloqueado se uma thread realizar um chamada 
    bloqueante ao sistema
    - Gerenciar threads em modo kernel é mais caro, devido as chamadas de sistemas
    e alternẫncia entre modo kernel e modo usuário

### Biblioteca POSIX Threads (pthreads)

  O padrão POSIX, usado nos sistemas baseados em UNIX, define uma API para criação e
manipulações de threads em modo kernel. As funções dessa API são:

- ``pthreads_create``
  - Cria uma nova threads
  - Header da função:
    ```c
      int pthread_create (pthread_t * thread, const pthread_attr_t * attr, void * (*start_routine)(void *), void *arg);
     ```
  - Ex: 
      ```c
      result = pthread_create (&th, NULL, função, NULL);
      ```
- ``pthread_exit``
  - Encerra a execução da thread
  -  Header:
      ```c
      void pthread_exit(void *value_ptr);
      ```
- ``pthread_join``
  - Suspende a execução da thread corrente até que a thread especificada termine, ou
  retorna imediatamente se essa thread já terminou.
  - Header:
    ```c
    int pthread_join(pthread_t thread, void **value_ptr);
    ```
- ``pthread_yield``
  - Libera a CPU para que outra thread seja executada
- ``pthread_attr_destroy``
  - Cria e inicializa uma estrutura de atributos da thread
- ``pthread_attr_destroy``
  - Remove uma estrutra de atributos do thread

Veja um exemplo em ``threads.c``

# Escalonamento de processos

 Escalonamento de processos é um mecanismo que o SO utiliza para gerenciar processos
que estão em estado de pronto.

O algoritmo de escalonamento pode ser:
- **Não preemptivo:** O processo executa até o fim, sem ser interrompido.
- **Preemptivo:** O processo pode ser interrompido pelo SO.
  - Usado para alternar processos
  - Os processos têm sua fatia de tempo (quantum)
