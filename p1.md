# Processos

Cria um processo com ``fork()``
  - Exemplo em ``fork.c``
  - Retorno:
    - para o filho: 0
    - para o pai: PID do filho
    - erro: -1
  - Duplica o processo atual, executando o novo processo num espaço de memória
  diferente.

Nos SO baseado em UNIX, o processo raiz (pai de todos os processos) é o **init**

### Quatro eventos para processos serem criados:

1. Inicialização do sistema.
2. Execução de uma chamada de sistema de criação de processo por um processo
em execução
3. Solicitação de um usuário para criar um novo processo
4. Início de uma tarefa em lote

### Condições que podem provocar o término de um processo

1. Saída normal (voluntária)
  - ``exit()``
2. Saída por erro (voluntária)
  - ex: ``gcc filename.c`` (mas filename.c não existe)
3. Erro Fatal (involuntária)
  - divisão por 0
  - segmetation fault (acesso indevido à memória)
  - execução de uma instrução ilegal
4. Destruído por outro processo (involuntária)
  - sinais (kill)

### Estados de um processo:

1. Em execução: realmente usando a CPU naquele instante
2. Pronto: executável, temporariamente parado para deixar outro processo
ser executado
3. Bloqueado: incapaz de ser executado até que algum evento externo aconteça
  - pode acontecer de duas formas:
    - chamada de sistema (block ou pause - SIGSTOP também ??)
    - quando não há entradas disponíveis para que o processo continue sua
    execução
4. Indefinido: processo desconhecido ao nível do SO

Transições entre **em execução** e **pronto** podem ocorrem num escalonamento de processos

### Tipos de Processos

- CPU-bound: procesos que utilizam muito o processador
  - tempo de exucução definido pelos ciclos de processador
- I/O-bound: processos que realizam muito entrada e saída
  - tempo de execução definido pela duração das operações E/S

O ideal é um balanceamento entre CPU-buond e I/O-bound

### Processos zombies:

Ocorre quando o processo filho acaba antes do processo pai sem o tratamento
adequado (wait ou waitpid). O processo está morto, portando não podemos usar
SIGKILL para matá-lo, mas ocupa espaço na memória.

# Sinais

- SO oferece sinais para enviar a algum processo
- Há como realizar tratamento de sinais
  - Obs: SIGKILL e SIGSTOP não podem ser capturados, bloqueados ou ignorados!
- Pode ser enviado sinais diretamento com kill
  - ``kill(pid_t pid, int sig)``

# Threads

Thread é uma linha de execução em um processo. E cada processo tem pelo menos uma thread

- As threads de um processo compartilham:
  - Espaço de endereço
  - Variáveis globais
  - Vetor de arquivos abertos
  - Processos filhos
  - Alarmes pendentes
  - O mesmo PID

- Cada thread tem seus próprios recursos:
  - PC
  - Registradores
  - Pilha
  - Estado
  - TID (identificador da thread)

Esquema para compartilhamaento de recursos do processo entre suas threads:

```
+-----------------------------------------------------------------------+ 
| Process                                                               | 
|   +-------+     +-------------+  +-------------+  +-------------+     | 
|   | Files |     | Thread      |  | Thread      |  | Thread      |     | 
|   +-------+     |+-----------+|  |+-----------+|  |+-----------+|     | 
|                 || Registers ||  || Registers ||  || Registers ||     | 
|                 |+-----------+|  |+-----------+|  |+-----------+|     | 
| ....................................................................  | 
| . Memory        |             |  |             |  |             |  .  | 
| .               | +---------+ |  | +---------+ |  | +---------+ |  .  | 
| . +--------+    | |  Stack  | |  | |  Stack  | |  | |  Stack  | |  .  | 
| . |  Heap  |    | |         | |  | |         | |  | |         | |  .  | 
| . +--------+    | |         | |  | |         | |  | |         | |  .  | 
| .               | |         | |  | |         | |  | |         | |  .  | 
| . +--------+    | |         | |  | |         | |  | |         | |  .  | 
| . | Static |    | |         | |  | |         | |  | |         | |  .  | 
| . +--------+    | |         | |  | |         | |  | |         | |  .  | 
| .               | |         | |  | |         | |  | |         | |  .  | 
| . +--------+    | |         | |  | |         | |  | |         | |  .  | 
| . |  Code  |    | +---------+ |  | +---------+ |  | +---------+ |  .  | 
| . +--------+    +-------------+  +-------------+  +-------------+  .  | 
| ....................................................................  | 
+-----------------------------------------------------------------------+ 

```

No Linux, as as threads e processos são tratados como tarefas, ou seja, não 
são vistas da mesma forma pelo SO. Só muda o que é compartilhado na memória
  - Isso é diferenciado pela chamada ``clone`` passando parametros diferentes

### Tipos de threads

- Modo usuário
  - As threads são implementadas por bibliotecas no nível do usuário
  - Criação e escalanomento são feitos sem usar o kernel (e são desconhecidas pelo kernel)
  - Cada processo tem sua própria tabela de threads
  - **Vantagens:**
    - Alternância de threads são mais rápidas
    - Tem menos chamadas ao kernel
    - Permite que cada processo tenha seu próprio algoritmo de escalonamento
  - **Desvantagem:**
    - Processo inteiro é bloqueado se uma thread realizar uma chamada bloqueante ao sistema
- Modo kernel:
  - Suportadas diretamente pelo SO
  - Escalonamento e gerenciamento feito pelo kernel
    - Tabela de threads e tabelas de processos separadas
  - **Vantagem:**
    - Processo inteiro não é bloqueado se uma thread realizar um chamada 
    bloqueante ao sistema
    - Gerenciar threads em modo kernel é mais caro, devido as chamadas de sistemas
    e alternẫncia entre modo kernel e modo usuário

### Biblioteca POSIX Threads (pthreads)

  O padrão POSIX, usado nos sistemas baseados em UNIX, define uma API para criação e
manipulações de threads em modo kernel. As funções dessa API são:

- ``pthreads_create``
  - Cria uma nova threads
  - Header da função:
    ```c
      int pthread_create (pthread_t * thread, const pthread_attr_t * attr, void * (*start_routine)(void *), void *arg);
     ```
  - Ex: 
      ```c
      result = pthread_create (&th, NULL, função, NULL);
      ```
- ``pthread_exit``
  - Encerra a execução da thread
  -  Header:
      ```c
      void pthread_exit(void *value_ptr);
      ```
- ``pthread_join``
  - Suspende a execução da thread corrente até que a thread especificada termine, ou
  retorna imediatamente se essa thread já terminou.
  - Header:
    ```c
    int pthread_join(pthread_t thread, void **value_ptr);
    ```
- ``pthread_yield``
  - Libera a CPU para que outra thread seja executada
- ``pthread_attr_destroy``
  - Cria e inicializa uma estrutura de atributos da thread
- ``pthread_attr_destroy``
  - Remove uma estrutra de atributos do thread

Veja um exemplo em ``threads.c``

# Escalonamento de processos

 Escalonamento de processos é um mecanismo que o SO utiliza para gerenciar processos
que estão em estado de pronto.

O algoritmo de escalonamento pode ser:
- **Não preemptivo:** O processo executa até o fim, sem ser interrompido.
- **Preemptivo:** O processo pode ser interrompido pelo SO.
  - Usado para alternar processos
  - Os processos têm sua fatia de tempo (quantum)

### Categorias de Algoritmos de Escalonamento

1. **Lote**: Não há terminal com usuários esperando repostas rápidas. Longo tempo
de intervalo para cada processo é aceitável
2. **Interativo** (propósito geral): a **preempção** é para evitar que um processo se aposse
da CPU, e com isso negue serviço aos outros.
3. **Tempo real**: preempção não é muito necessária pos geralmente os processos nesess
sistemas são realizados rapidamente.

### Objetivos de algoritmos de escalonamento:

#### Todos os sistemas
- Justiça: dar a cada processo uma porção justa da CPU;
- Políticas do Sistema: verificar se a política estabelecida é cumprida
- Balanceamento - diminuir a ociosidade do sistema

#### Sistemas em Lote
- Taxa de execução: maximizar o número de tarefas por hora
- Tempo de retorno (Turnaroun time): minimizar o tempo entre a submissão e o término
- Utilização de CPU - manter a CPU ocupada o tempo todo
- Tempo de espera: tempo gasto na fila de prontos. (isso não é bem um objetivo, 
mas OK ¯\_(ツ)_/¯)

#### Sistems interativos
- Tempo de resposta: minimizar o tempo esperando para iniciar a execução
- Proporcinalidade: satisfazer às expectativas dos usuários

#### Sistemas de tempo real
- Cumprimento dos prazos: evitar a perda de dados
- Previsibilidade: prevenir perda da qualidade dos serviços oferecidos

#### Objetivos Gerais
- Maximizar a utilização da CPU (manter o processador ocupado)
- Maximizar a vazão (_throughput_) do sistema
- Minimizar o tempo de execução (_turnaround time_)
- Minimizar o tempo de espera (_waiting time_)
- Minimizar o tempo de resposta (_response time_)

### Algoritmos para Sistemas em Lote 
- First-Come First-Served (FIFO, fila)
- Shortest Job First (SJF)
- Shortest Remaining Time Next (SRTN)

#### First-Come First-Served
- Não-preemeptivo
- Cada processo que chega é inserido na fila
- É executado o primeiro processo da fila

#### Shortest Job First
- Não-preemptivo
- Menor processo é execudado primeiro
- Menor turnaround time

#### Shortest Remaining Time Next
- Preemptivo
- Processos com menor tempo de execução são executados primeiro
- Se um processo novo chega com um tempo menor que o processo corrente, o processo atual
é interrompido e o novo processo é executado.

### Algoritmos para Sistemas Interativos
- Round-Robin
- Prioridade
- Múltiplas Filas
- Shortest Process Next
- Garantido
- Lottery
- Fair-Share

#### Round-Robin
- Preemptivo
- Cada processo é atribuído um **quantum** (intervalo de tempo)
- Se ao final do **quantum** o processo não terminou, a CPU sofre uma preempção
e o próximo processo é colocado em execução
- Escalonador mantém uma lista de processos prontos
- Quantum:
  - muito pequeno - ocorrem muitas trocas, diminuindo a eficiência da CPU
  - muito longo - o tempo de resposta é comprometido

#### Escalonamento por Prioridades
- Preemptivo
- Cada processo possui uma prioridade
- Processos prontos com maior prioridades são executados primeiro
- Para evitar que processos de alta prioridade executem infinitamente, o escalonador
pode reduzir a prioridade do processo a cada execução do mesmo.
- Prioridades pode ser setados pelo comando ``nice`` ou ``renice``
  - ``nice [-n PRIORIDADE] [comando ...]``
  - ``renice [-p PID]``


---------

**Referências:**
- Sistemas Operacionais Modernos; Tanembaum, A. S.
- Slides de aula da Prof. Kelen Cristiane Teixeira Vivaldini

- Notas de aula do Prof. Hélio Crestana Guardia
